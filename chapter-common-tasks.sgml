    <chapt id="common-tasks">
      <heading>Common kernel-related tasks</heading>
      <sect id="common-getting">
        <heading>Obtaining the Debian kernel source</heading>
	<p>
	  To get the Debian kernel source at the current maximum patchlevel,
	  it is sufficient to install the latest <tt>linux-source-<em>version</em></tt>
	  package and unpack the source, for example:
	  <example>
# apt-get install linux-source-2.6.18
$ tar jxf /usr/src/linux-source-2.6.18.tar.bz2
          </example>
	  The unpacked source tree then will be available in <tt>linux-source-2.6.18</tt> directory.
	</p>
	
	<p>
	  In order to get the Debian kernel source at the patchlevel
	  <em>different</em> from the one provided by the current
	  <tt>linux-source-<em>version</em></tt> package, one should
	  first install and unpack it, then roll back the unneeded
	  patch sets using a script from the <tt>linux-patch-debian-<em>version</em></tt> 
	  package. We assume that in the steps mentioned in the
	  previous example the version 2.6.18-8 of the
	  <tt>linux-source-2.6.18</tt> package was installed and
	  unpacked, so that the Debian kernel source at patchlevel 8 is
	  available in the <tt>linux-source-2.6.18</tt> directory. It
	  can then be rolled back to the desired patchlevel (1 in the
	  example below) by running
	  <example>
# apt-get install linux-patch-debian-2.6.18
$ cd linux-source-2.6.18
$ /usr/src/kernel-patches/all/2.6.18/apply/debian 2.6.18-1
          </example>
	  The last command will <em>unapply</em> the set of patches,
	  which lead from patchlevel 1 to patchlevel 8 and the
	  resulting tree will appear as if it came from the version
	  2.6.18-1 of the <tt>linux-source-2.6.18</tt> package. This
	  system ensures that the source code for any revision of the
	  Debian kernel source may be recovered from the latest one,
	  without keeping multiple copies of the source in the
	  archive.
	</p>

	<p>

	  The version <tt><em>version</em>-<em>N</em></tt> (like
	  2.6.18-8) of the <tt>linux-patch-debian-<em>version</em></tt> 
	  package contains all the individual patches applied to the
	  source to achieve any patchlevel up to <tt><em>N</em></tt>.
	  They are stored in the directory
	  <tt>/usr/src/kernel-patches/all/<em>version</em>/debian/</tt>.

	</p>

      </sect>
      <sect id="common-official">
        <heading>Rebuilding an official Debian kernel package</heading>
	<p>
	  To locally build a kernel image identical to the one
	  distributed in the Debian archive use the following
	  procedure:
	  <taglist>
	    <tag><tt>$ apt-get source linux-2.6</tt></tag>	      
	    <item>
	      This will download and unpack the
	      <tt>linux-2.6</tt> source package, making the
	      tree available in the
	      <tt>linux-2.6-<em>version</em></tt>
	      directory. As always, the revision part of the version
	      of this package (for example, 8 in 2.6.18-8) will
	      determine its patchlevel with respect to the original
	      upstream kernel source.
	    </item>
	    <tag><tt># apt-get install build-essential fakeroot</tt></tag>
	    <tag><tt># apt-get build-dep linux-2.6</tt></tag>
	    <item>
	      The last two commands will install the build dependencies required by the kernel
	      build process.
	    </item>
	    <tag><tt>$ cd linux-2.6-<em>version</em></tt></tag>
	    <tag><tt>$ fakeroot debian/rules binary</tt></tag>
	    <item>
	      The last command will start the kernel build and should
	      result in creation of the kernel packages, identical to
	      the official ones in the original directory (in which
	      the source package was unpacked). It is possible to
	      specify the targets <tt>binary-arch</tt> or
	      <tt>binary-indep</tt> targets instead of the
	      <tt>binary</tt>, if only architecture-dependent (such as
	      the <tt>linux-image</tt>) or architecture-independent
	      packages are required. It is possible to further
	      restrict the build to only the desired flavours of the
	      kernel images by invoking the individual targets directly.
	      For example, to build only the binary packages for 686 
	      flavour on i386 architecture, use the following commands:
	      <example>
$ fakeroot debian/rules debian/build debian/stamps
$ fakeroot make -f debian/rules.gen binary-arch_i386_none_686
	      </example>
	      The target in the last command has general form of
	      <tt><em>target</em>-<em>arch</em>-<em>subarch</em>-<em>flavour</em></tt>.
	      Replace the <tt><em>subarch</em></tt> with <tt>none</tt> if it is empty.
	    </item>
	  </taglist>
	</p>
	
	<p>
	  It is possible to apply extra patches to the tree before
	  starting the build. To do that, before invoking the
	  <tt>binary</tt> or <tt>binary-arch</tt> target, use the
	  <tt>setup</tt> target to unpack the tree and prepare it for
	  a build:
	  <example>
$ fakeroot debian/rules debian/build debian/stamps
$ fakeroot make -f debian/rules.gen setup_i386_none_686
	  </example>
	  This will unpack the kernel tree in the
	  <tt>debian/build/build-i386-none-686</tt> directory, where the extra
	  patches may be applied. After that the <tt>binary</tt> or
	  <tt>binary-arch</tt> target may be invoked to complete the
	  build, as described above.
	</p> 
      </sect>

      <sect id="gen-orig">
        <heading>Generating orig tarball from newer upstream</heading>
	<p>First you need to fetch from kernel.org the latest upstream
	   source and patch. This will allow the genorig script to
	   generate a newer orig.tar.gz:
	  <example>
$python debian/bin/genorig.py ../linux-2.6.20.tar.bz2 ../patch-2.6.21-rc6.bz2
	  </example>
	  That will generate the following file 
	  <tt>../orig/linux-2.6_2.6.21~rc6.orig.tar.gz</tt>. Unpack it and
	  apply the cmds of the previous chapter.
	</p> 
      </sect>

      <sect id="common-building">
        <heading>Building a custom kernel from Debian kernel source</heading>
	<p>
	  This section describes the simplest possible procedure to
	  build a custom kernel the "Debian way". It is assumed that
	  user is somewhat familiar with kernel configuration and
	  build process. If that's not the case, it is recommended to
	  consult the kernel documentation and many excellent online
	  resources dedicated to it.
        </p>
	<p>
	  The easiest way to build a custom kernel (the kernel with
	  the configuration different from the one used in the
	  official packages) from the Debian kernel source is to use
	  the <tt>linux-source</tt> package and the <tt>make-kpkg</tt>
	  command, provided by the <tt>kernel-package</tt> package.
	  First, prepare the kernel tree:
	  <example>
# apt-get install linux-source-2.6.18
$ tar xjf /usr/src/linux-source-2.6.18.tar.bz2
$ cd linux-source-2.6.18
          </example>
	  The kernel now needs to be configured, that is you have to
	  set the kernel options and select the drivers which are
	  going to be included, either as built-in, or as external
	  modules. The kernel build infrastructure offers a number of
	  targets, which invoke different configuration frontends. For
	  example, one can use console-based menu configuration by
	  invoking the command
	  <example>
$ make menuconfig
          </example>
	  Instead of <tt>menuconfig</tt> one can use <tt>config</tt>
	  (text-based line-by-line configuration frontend) or
	  <tt>xconfig</tt> (graphical configuration frontend). It is
	  also possible to reuse your old configuration file by
	  placing it as a <tt>.config</tt> file in the top-level
	  directory and running one of the configuration targets (if
	  you want to adjust something) or <tt>make oldconfig</tt>
          (to keep the same configuration).
	  Note that different frontends may require different
	  additional libraries and utilities to be installed to
	  function properly. For example, the <tt>menuconfig</tt>
	  frontend requires the <tt>ncurses</tt> library, which at
	  time of writing is provided by the <tt>libncurses5-dev</tt>
	  package.
	</p>
	<p>
	  After the configuration process is finished, the new or
	  updated kernel configuration will be stored in
	  <tt>.config</tt> file in the top-level directory. Once it's
	  in place, you need to decide whether you want a kernel with
	  or without initrd/initramfs support.  See <ref id="initramfs"> for
	  details on what initrd is. If you decide to go for a
	  initrd-enabled kernel, it should include the initrd support
	  in its configuration. The build for a non-initrd kernel is
	  started using the commands
	  <example>
$ make-kpkg clean
$ fakeroot make-kpkg --revision=custom.1.0 kernel_image
          </example>
	  The <tt>custom.1.0</tt> part in this command is the version
	  identifier, which will get appended to the kernel package
	  name. Feel free to adjust it to your liking. For an
	  initrd-enabled kernel add an extra <tt>--initrd</tt> argument
	  to the second command:
	  <example>
$ make-kpkg clean
$ fakeroot make-kpkg --initrd --revision=custom.1.0 kernel_image
          </example>
	  As a result of the build a custom kernel package
	  <tt>linux-image-2.6.18_custom.1.0_i386.deb</tt> (name will
	  reflect the version of the kernel and the revision chosen in
	  the command line above) will be created in the directory one
	  level above the top of the tree. It may be installed using
	  <tt>dpkg</tt> as any other package:
	  <example> 
# dpkg -i ../linux-image-2.6.18_custom.1.0_i386.deb
	  </example>
	  This command will unpack the kernel, generate the initrd if
	  necessary (see <ref id="initramfs"> for details), and configure
	  the bootloader to make the newly installed kernel the
	  default one. If this command completed without any problems,
	  you can reboot using the
	  <example>
# shutdown -r now
          </example>
	  command to boot the new kernel.
	</p>
	<p>
  	  For much more information about <tt>make-kpkg</tt>,
	  bootloaders and their configuration please check their
	  documentation, which can be accessed using the commands
	  <tt>man make-kpkg</tt>, <tt>man lilo</tt>, <tt>man
	  lilo.conf</tt>, <tt>man grub</tt>, and so on. You can also
	  look for documentation in the
	  <tt>/usr/share/doc/<em>package</em></tt> directories, with
	  <tt><em>package</em></tt> being the name of the package
	  involved.
	</p>  
      </sect>

      <sect id="kernel-org-package">
        <heading>Building a custom kernel from the "pristine" kernel source</heading> 
	<p>Building a kernel from the "pristine" (also sometimes called "vanilla")
           kernel source, distributed from <url id="http://www.kernel.org" name="www.kernel.org">
           and its mirrors, may be occasionally useful for debugging or in the
           situations when a newer kernel version is desired. The procedure
           differs only in obtaining the kernel source: instead of unpacking
           the kernel source from Debian packages, the "pristine" source is
           downloaded using your favourite browser or using wget, as follows: 
	  <example> 
$ wget http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.19.tar.bz2
	  </example> 
          The integrity of the downloaded archive may be verified by fetching
          the corresponding cryptographic signature
	  <example> 
$ wget http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.19.tar.bz2.sign
	  </example> 
          and running the command (<tt>gnupg</tt> package must be installed):
          <example>
$ gpg --verify linux-2.6.19.tar.bz2.sign 
          </example>
          Successful verification results in output similar to the one below:
          <example>
gpg: Signature made Wed 29 Nov 2006 02:50:07 PM PST using DSA key ID 517D0F0E
gpg: Good signature from "Linux Kernel Archives Verification Key &lt;ftpadmin@kernel.org&gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: C75D C40A 11D7 AF88 9981  ED5B C86B A06A 517D 0F0E
          </example>
          After that the archive may be unpacked using
          <example>
$ tar xjf linux-2.6.19.tar.bz2
$ cd linux-2.6.19
          </example>
          The unpacked kernel tree (in <tt>linux-2.6.19</tt> now has to be configured.
          The existing configuration file may be used as a starting point
          <example>
$ cp /boot/config-2.6.18-3-686 ./.config
          </example>
          After the configuration with one of the configuration frontends (invoked by <tt>make oldconfig</tt>,
          <tt>make config</tt>, <tt>make menuconfig</tt>, etc) is completed, the build 
          may be started using <tt>make-kpkg</tt> command as described above.
      </sect>

      <sect id="common-out-of-tree">
        <heading>Building out-of-tree kernel modules</heading> 
	<p>
	  Some kernel modules are not included in the upstream or
          Debian kernel source, but are provided as third-party source
          packages. For some of the most popular out-of-tree modules,
          the binary Debian packages with modules built against the
          stock Debian kernels are provided. For example, if you are
          running stock Debian kernel <tt>2.6.18-3-686</tt> (use the
          <tt>uname -r</tt> command to verify the version) from the
          <tt>linux-image-2.6.18-3-686</tt> package, and would like to
          use the squash filesystem, all you need to do is install
          <tt>squashfs-modules-2.6.18-3-686</tt> binary package, which
          provides the neccessary binary kernel modules.
	</p>

        <p>
          If you are not so lucky, and there are no binary module
          packages in the archive, there is a fair chance that the
          Debian archive contains the packaged <strong>source</strong>
          for the kernel modules. Names of such packages typically end
          in <tt>-source</tt>, for example <tt>squashfs-source</tt>,
          <tt>thinkpad-source</tt>, <tt>rt2x00-source</tt> and many
          others. These packages contain debianized source code of the
          kernel modules, suitable for building using the
          <tt>module-assistant</tt> (or <tt>m-a</tt>) script from the
          <tt>module-assistant</tt> package.  Typical sequence to
          build a custom binary module package, matching a kernel
          <tt>2.6.18-3-686</tt> (as returned by <tt>uname -r</tt>)
          from the debianized source consists of the following steps:
         </p>
         <p>
          Install a set of kernel headers, matching the kernel for
          which the modules are going to be built:
          <example>
# apt-get install linux-headers-2.6.18-3-686
          </example>
          Install the package containing the source:
          <example>
# apt-get install squashfs-source
          </example>
          Invoke <tt>module-assistant</tt> (aka <tt>m-a</tt>) to do
          the heavy lifting:
          <example>
# m-a build squashfs
          </example>
          As a result, a Debian package is going to be built and placed
          in <tt>/usr/src</tt>. It can be installed the usual way, using
          <tt>dpkg -i</tt>. Two last steps (building and installation)
          may be combined using the invocation
          <example>
# m-a auto-install squashfs
          </example>
          Check out the <tt>module-assistant</tt> documentation (<tt>man module-assistant</tt>)
          for other options and much more information on how to use it.
        </p>

        <p>
          Finally, in some rare circumstances, you might need to build the kernel modules
          from the upstream source packages. In that case, follow the documentation included
          with the package to build the modules. If the build process will
          require you to specify the directory with the kernel headers,
          matching the currently running kernel, for stock Debian kernels this directory is
          <tt>/usr/src/linux-headers-<em>uname</em></tt>, provided by the 
          <tt>linux-headers-<em>uname</em></tt> package. Here <tt><em>uname</em></tt> is the
          output of the <tt>uname -r</tt> command. If you are building and running your own
          custom kernels, it is a good idea to keep the original build tree around, as it
          also can be used for out-of-tree module building.
        </p>
      </sect>
    </chapt>
