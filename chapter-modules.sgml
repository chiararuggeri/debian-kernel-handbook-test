<chapt id="modules">
  <heading>Managing the kernel modules</heading>
  <p>

    Linux device drivers come in the form of kernel modules - object
    files which may be loaded into the running kernel to extend its
    functionality. The list of currently loaded kernel modules can be
    obtained using the <tt>lsmod</tt> command, modules may be loaded
    using <tt>modprobe</tt>, and removed using <tt>modprobe -r</tt>.
    The <tt>depmod</tt> command may be used to regenerate the list of
    available modules (after installation of the new modules, for
    example), even though it is pretty unlikely that you will ever
    need to invoke it by hand.
 
  </p>
  <p>

     Normally, the devices are detected and neccessary kernel modules
     are loaded by <tt>udev</tt> during boot time. Occasionally, one
     may need finer control over the loading of kernel modules, for
     example to pass the additional parameters to the module, force
     loading of some modules on startup, or prevent certain module(s)
     from being loaded.

   </p>
   <p>
     
     If some modules are not loaded automatically by <tt>udev</tt>, but
     you would like them to be loaded during boot, it is possible to force
     it by listing the names of the modules in <tt>/etc/modules</tt>.
     This will be scanned for the names of
     the modules (one name per line), which will then be loaded using
     <tt>modprobe</tt>. You can also specify the arguments for the modules.
     For example, a typical <tt>/etc/modules</tt> might look like that
     <example>
loop max_int=32
sbp2
     </example>
     To find out what parameters are accepted by a given module, you can
     use the <tt>modinfo</tt> command, for example:
     <example>
# modinfo loop
filename:       /lib/modules/2.6.18-3-686/kernel/drivers/block/loop.ko
license:        GPL
alias:          block-major-7-*
vermagic:       2.6.18-3-686 SMP mod_unload 686 REGPARM gcc-4.1
depends:        
parm:           max_loop:Maximum number of loop devices (1-256) (int)
     </example>

   </p>
   <p>

     To add custom arguments to the modules loaded by <tt>udev</tt>
     early in the boot process, you need to create a custom
     configuration file for <tt>modprobe</tt>, which <tt>udev</tt>
     uses to load the modules.  For example, to pass an
     <tt>atapi_enabled=1</tt> argument to the <tt>libata</tt> kernel
     module, create <tt>/etc/modprobe.d/local</tt> file with a
     following line:
     <example>
options libata atapi_enabled=1
     </example>
     You can choose arbitrary names for the configuration files in
     <tt>/etc/modprobe.d</tt> and put multiple <tt>options</tt> lines in
     the same file.

   </p>
   <p>
     Sometimes two different modules claim support for the same
     device, usually because two slightly different versions of the
     device exist, requiring different kernel modules to operate. In
     such situation <tt>udev</tt> loads both kernel modules, with
     unpredictable results.  To avoid this problem, you can prevent
     any module (let's say, <tt>tulip</tt>) from loading by creating
     an arbitrarily named file, containing a line
     <example>
blacklist tulip
     </example>
     in <tt>/etc/modprobe.d</tt> directory. See the <tt>modprobe</tt>
     manual page (<tt>man modprobe</tt>) for much more information on
     configuring and using modprobe.
    </p>
</chapt>
