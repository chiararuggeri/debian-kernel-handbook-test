<!doctype debiandoc system [
<!-- include version information so we don't have to hard code it
     within the document -->
<!entity % versiondata SYSTEM "version.ent"> %versiondata;
]>
<debiandoc>

  <book>
    <titlepag>
      <title>Debian Linux Kernel Handbook</title>
      <author><qref id="authors">The Debian Kernel Handbook Project</qref></author>
      <version>version &version;, &date;</version>

      <copyright>
	<copyrightsummary>
	  Copyright &copy; 2005, 2006 Debian Kernel Handbook Project
	</copyrightsummary>
	<p>
	  This handbook is free software; you may redistribute it and/or
	  modify it under the terms of the GNU General Public License
	  as published by the Free Software Foundation; either version
	  2, or (at your option) any later version.
	</p>

	<p>
	  This is distributed in the hope that it will be useful, but
	  <em>without any warranty</em>; without even the implied
	  warranty of merchantability or fitness for a particular
	  purpose.  See the GNU General Public License for more
	  details.
	</p>

	<p>
	  A copy of the GNU General Public License is available as
	  <file>/usr/share/common-licenses/GPL</file> in the Debian GNU/Linux
	  distribution or on the World Wide Web at
	  <url id="http://www.gnu.org/copyleft/gpl.html"
	       name="the GNU General Public Licence">. You can also
	  obtain it by writing to the Free Software Foundation, Inc.,
	  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
	</p>
      </copyright>
    </titlepag>

    <toc detail="sect1">

    <chapt id="scope">
      <heading>About this handbook</heading>
      <sect>
	<heading>Scope</heading>
	<p>
	  The main goal of this handbook is to serve as a single
	  access point to all kernel-related documentation. It
	  currently only contains the information about the Debian
	  packaging of Linux kernel 2.6.12 and higher. The latest
	  released version is always available from 
	  <url id="http://kernel-handbook.alioth.debian.org" name="http://kernel-handbook.alioth.debian.org">.
	</p>
	<p>
	  Some of the commands mentioned in the text must be executed
	  with superuser priviliges, either by becoming the <tt>root</tt> user
	  or by using <tt>sudo</tt>. To distinguish between commands which
	  may be executed by an unprivileged user and those requiring
	  superuser privileges, commands are prepended by <tt>$</tt>
	  or <tt>#</tt> respectively. This symbol is not a part of
	  the command.
      </sect>
      <sect id="authors">
        <heading>Authors and Contributors</heading>
	<p>

	  This handbook is maintained within the <url
	  id="http://alioth.debian.org/projects/kernel-handbook"
	  name="kernel-handbook"> project on <url
	  id="http://alioth.debian.org" name="Alioth">. The SGML
	  source of the book may be checked out from the Debian 
	  subversion (svn) repository at <url
	  id="http://svn.debian.org/wsvn/kernel-handbook/trunk/"
	  name="svn://svn.debian.org/svn/kernel-handbook/trunk/">. It is
	  intended as a community project, thus all the proposals for
	  improvements and contributions are welcome. The preferred
	  way to submit a contribution is to send it to the
	  <tt>kernel-handbook-general@lists.alioth.debian.org</tt>
	  mailing list. When submitting a contribution please clearly
	  identify its copyright holder and include the licensing
	  statement. Note that to be accepted the contribution must be
	  licensed under the same license as the rest of the document,
	  namely GPL version 2 or later. Below is the list of current
	  contributors:

	  <list>
	    <item>Jurij Smakov</item>
	    <item>Sven Luther</item>
	    <item>Andres Salomon</item>
	    <item>Maximilian Attems</item>
	  </list>
	</p>
      </sect>
    </chapt>


    <chapt id="source">
      <heading>Debian kernel source</heading>
      <sect id="changes">
        <heading>Changes to the pristine kernel source</heading>
        <p>
	  The kernels in Debian are distributed in binary form, built
	  from the Debian kernel source. It is important to recognize
	  that Debian kernel source may (and in most cases is)
	  different from the upstream (or "pristine") kernel source,
	  distributed from <url id="http://www.kernel.org"
	  name="www.kernel.org"> and its mirrors. Due to licensing
	  restrictions, unclear license information, or failure to
	  comply with the Debian Free Software Guidelines (DFSG) parts
	  of the kernel must be removed in order to distribute the
	  source in the <tt>main</tt> section of the Debian
	  archive. The removal procedure is typically performed by a
	  <tt>prune-non-free</tt> script, available in the Debian
	  kernel SVN repository <footnote>
	  <tt>svn://svn.debian.org/kernel/trunk/scripts/prune-non-free</tt>
	  </footnote> and producing the
	  <tt>linux-<em>major</em>_<em>version</em>.orig.tar.gz</tt>
	  tarball, which serves as the original upstream
	  source. <em>major</em> is the kernel major version (like
	  2.6) and <em>version</em> is the actual upstream version.
	  The removed parts are packaged as
	  <tt>linux-nonfree-<em>major</em>_<em>version</em>.orig.tar.gz</tt>,
	  which serves as the original tarball for the
	  <tt>linux-nonfree</tt> package.

	  The drivers which are currently removed from the pristine
	  kernel source and those under consideration are listed on
	  the <url id="http://wiki.debian.org" name="Debian Wiki">
	  page <url
	  id="http://wiki.debian.org/KernelFirmwareLicensing"
	  name="KernelFirmwareLicensing">.
	  
	</p>
      <sect id="patches">
        <heading>Debian kernel patches</heading>
        <p>
	  The source from which the Debian binary kernels are built is
	  obtained by taking the source from
	  <tt>linux-<em>major</em>_<em>version</em>.orig.tar.gz</tt>
	  (that is, pristine kernel source, processed by the
	  <tt>prune-non-free</tt> script) and applying a set of Debian
	  patches. These patches typically implement essential fixes
	  for serious bugs and security holes. The Debian version of
	  the kernel packages has the form
	  <tt><em>version-revision</em></tt> where
	  <tt><em>version</em></tt> is the upstream version of the
	  kernel (like 2.6.12) and <tt><em>revision</em></tt>
	  determines the patchlevel. For example, the packages with
	  version 2.6.12-3 are built from the
	  <tt>linux-2.6_2.6.12.orig.tar.gz</tt> source, patched up to
	  patchlevel 3. Additionally, some architectures (such as
	  <tt>hppa</tt>) require architecture-specific patches for the kernel
	  to build and operate.
	</p>
	<p>
	  All the patches used in the process of building of the
	  Debian official kernel packages are shipped as a part of
	  <tt>linux-patch-debian-<em>version</em></tt> package.  See
	  its description in <ref id="arch-indep"> for more
	  information about the patch system.
        </p>
      </sect>
      <sect id="acceptance">
        <heading>Policy for patch acceptance</heading>
      <p>
        The goal of the Debian kernel team is to keep the difference
	between the Debian kernel source and the "pristine" kernel
	source to a minimum.  That typically means that only the
	patches fixing security holes and serious kernel bugs are
	going to be considered for the inclusion in the Debian kernel
	source. The recommended procedure for inclusion of patches
	introducing optional features is to package them as separate
	patch packages, or to convince the upstream maintainer to
	include them in the next kernel release.
      </p>
      </sect>
    </chapt>

    <chapt id="packaging">
      <heading>Debian kernel packages</heading>
      <sect id="source-pkg">
        <heading>Source package</heading>
	<p>
	  To ensure that the latest kernel version, containing all the
	  essential bug and security fixes is available on as many
	  architectures as possible, starting with 2.6.12 the kernel
	  team introduced a new packaging scheme. In it all the
	  kernel-related binary packages are built from a single
	  source package <tt>linux-<em>major</em></tt>. As of 2.6.12-2
	  release the common source package <tt>linux-2.6</tt>
	  supports (with varying degree of success) the building of
	  kernel images and headers for all currently supported
	  architectures. Subsequent sections of this chapter document
          the naming and contents of the binary packages built from the
	  <tt>linux-<em>major</em></tt> source package.
	</p>
	  
      <sect id="arch-indep">
        <heading>Architecture-independent packages</heading>
        <p>
        <taglist>
          <tag><tt>linux-source-<em>version</em></tt></tag> 
	  <item>
 	    This package contains the Debian kernel source
	    tarball. The patchlevel of the source is determined by the
	    version of the package, for example the version 2.6.12-3
	    of the package <tt>linux-source-2.6.12</tt> contains the
	    version 2.6.12 of the Debian kernel source patched to patchlevel 3. 
	    Once the package is installed, the source
	    tarball is available at
	    <tt>/usr/src/linux-source-<em>version</em>.tar.bz2</tt>. For the
	    instructions on obtaining Debian kernel source with arbitrary
	    patchlevel, see <ref id="common-getting">.
	  </item>
	  <tag><tt>linux-manual-<em>version</em></tt></tag>
	  <item>
	    This package contains the manual pages for the functions,
	    constituting the kernel API. These pages are installed
	    into <tt>/usr/share/man/man9/</tt>, and are accessible
	    with the standard <tt>man</tt> command. Only one
	    <tt>linux-manual</tt> package for a particular kernel
	    version may be installed in the system at any given time.
	  </item>
	  <tag><tt>linux-doc-<em>version</em></tt></tag>
	  <item>
	    This package contains the rest of the kernel documentation
	    in various formats. It is installed in
	    <tt>/usr/share/doc/linux-doc-<em>version</em></tt>.
	  </item>
	  <tag><tt>linux-patch-debian-<em>version</em></tt></tag>
	  <item>
	    This package contains all patches used to produce the
	    Debian kernel source. It also contains the scripts which allow
	    application or un-application of patchsets, bringing the source
	    to the desired patchlevel. After the installation the patches
	    are installed in <tt>/usr/src</tt> as follows:
	    <taglist>
	    <tag><tt>/usr/src/kernel-patches/all/<em>version</em>/debian/</tt></tag>
	    <item>
	      This directory contains the individual patch files for a given
	      version.
	    </item>
	    <tag><tt>/usr/src/kernel-patches/all/<em>version</em>/debian/series/</tt></tag>
	    <item>
	      This directory contains the control files, which
	      determine which patches need to be applied (or
	      unapplied) to move from one patchlevel to another. These
	      are text files named
	      <tt><em>version</em>-<em>N</em></tt>, containing the list
	      of patches which need to be applied (in case when the
	      name of the patch prepended with plus) or unapplied (if
	      it is prepended with a minus) to move from patchlevel
	      <tt><em>N</em>-1</tt> to patchlevel <tt><em>N</em></tt>.
	      For example, the file <tt><em>version</em>-1</tt> lists
	      the patches which need to be applied to go from the
	      original upstream source to the patchlevel 1. Similarly,
	      the file <tt><em>version</em>-4</tt> describes the
	      patchset which makes a tree at patchlevel 4 from the one
	      at patchlevel 3.
	    </item>
	    <tag><tt>/usr/src/kernel-patches/all/<em>version</em>/apply/debian</tt></tag>
	    <item>
	      This script may be used to change the patchlevel of the
	      currently available source tree, when run from its
	      top-level directory. For usage example see <ref id="common-getting">.
	    </item>  
	    <tag><tt>/usr/src/kernel-patches/diffs/<em>arch</em>_<em>uversion</em>/</tt></tag>
	    <item>
	      Some architectures (actually, only <tt>hppa</tt> at time of writing) require extra
	      changes to the upstream kernel source in order to produce a working kernel. 
	      This directory contains the patches specific to architecture <tt><em>arch</em></tt>
	      (if any), which are applied (in addition to other architecture-independent Debian 
	      patches) to build the official Debian kernel for this architecture.
	      <tt><em>uversion</em></tt> in the name stands for the upstream kernel version with
	      dots replaced by underscores, for example 2_6_12 for kernel version 2.6.12. This
	      layout and naming scheme ensure that the extra patches may be applied automatically
	      during kernel build by passing
	      the <tt>--added-patches</tt> argument to <tt>make-kpkg</tt>. 
	    </item>  
	    <tag><tt>/usr/src/kernel-patches/<em>arch</em>/apply/<em>arch</em>_<em>uversion</em></tt></tag>
	    <item>
	      This script applies the architecture-specific patch for architecture 
	      <tt><em>arch</em></tt> and version correspoinding to <tt><em>uversion</em></tt>.
	      It is not intended to be run directly, but rather invoked by <tt>make-kpkg</tt> when
	      the <tt>--added-patches</tt> argument is specified on the command line. For more
	      information see <ref id="common-building"> and <tt>kernel-package</tt> documentation.
	    </item>
	  </taglist>
	</item> 
        <tag><tt>linux-tree-<em>version</em></tt></tag> 
	<item>
	    This is a dummy package whose sole purpose is to satisfy
	    the build dependencies for a successful kernel build. In
	    the old kernel build system build-depending on the package
	    <tt>linux-tree-<em>version</em>-<em>N</em></tt>, provided
	    by the <tt>linux-tree-<em>version</em></tt>, would result
	    in the automatic installation of all the required source
	    and patch packages, and patching of the kernel source to
	    patchlevel <tt><em>N</em></tt> before building. It has
	    been obsoleted by the new common packaging system
	    introduced since kernel 2.6.12 and is provided only for
	    backward compatibility with architectures, not yet
	    supported by the common source package or not controlled
	    by the Debian kernel team.
	</item>
      </taglist>
      </p>
      </sect>
      <sect id="arch-dep">
        <heading>Architecture-dependent packages</heading>
	<p>
	  The kind of hardware the particular kernel package is
	  designed for is uniquely identified by the
	  <em>architecture</em>, <em>subarchitecture</em>, and
	  <em>flavour</em>. Kernels for most architectures are built
	  from the same Debian kernel source tree, which is obtained
	  using the procedure described in <ref id="source">. Each
	  architecture usually has multiple flavours of the binary
	  kernel images. Different flavours correspond to different
	  kernel configuration files, used to build the binary images
	  from the <strong>same</strong> kernel tree.
	</p>

	<p>
	  In order to build a working kernel for certain classes of
	  hardware, additional changes to the Debian kernel source may
	  be required. In that case, the patch set applied to produce
	  a modified tree determines the subarchitecture.  Again,
	  multiple flavours of binary images may be build from the
	  subarchitecture tree. For example, the <tt>powerpc</tt>
	  architecture may have <tt>power4</tt> and
	  <tt>power4-smp</tt> flavours, built from the common Debian
	  kernel source, as well as an <tt>apus</tt>
	  subarchitecture. Tree for that subarchitecture is obtained
	  by applying <tt>apus</tt>-specific patches to the Debian
	  kernel source. This tree may be further used to build the
	  <tt>apus-up</tt> and <tt>apus-smp</tt> binary image flavours
	  <footnote> This example is for illustrative purposes only.
	  Currently there are no supported subarchitectures in Debian.
	  </footnote>. All the flavour identifiers across all
	  architectures and subarchitectures are unique, so that the
	  flavour name may be uniquely mapped to a (sub)architecture,
	  if need arises.  The names of the Debian binary packages
	  incorporate the name of the flavour and, if necessary, the
	  name of the subarchitecture (there is no need to worry about
	  the name of the architecture, since Debian tools will only
	  allow installation of the packages with "correct"
	  architecture). If the arch does not have any subarches, the
	  subarch part is omitted from the name, as indicated by the
	  square brackets below.
	</p>
	<p>
	  Package names also include the <em>abiname</em>, a small
	  integer, which identifies the kernel's compatibility
	  level. The kernels with different abinames are binary
	  incompatible, so upgrading to a kernel with a different
	  abiname will most likely require recompilation of
	  third-party binary modules against the new kernel. The list
	  of architecture-dependent packages together with a short
	  description is given below.
        </p>
	<p>
	  <taglist>
	  <tag><tt>linux-headers[-<em>subarch</em>]-<em>version</em>-<em>abiname</em></tt></tag>
	  <item>
	    This package contains a common set of kernel headers for a particular
	    subarch (or arch, if subarch is empty). Together with the flavour-specific
	    <tt>linux-headers</tt> package it provides a full set of kernel headers,
	    suitable for building of out-of-tree modules. This package should not normally
	    be installed directly, but only as a dependency of the flavour-specific
	    headers package (see next description). It unpacks into the 
	    <tt>/usr/src/linux-headers[-<em>subarch</em>]-<em>version</em>-<em>abiname</em></tt>
	    directory.
	  </item>
	  </taglist>
	  <taglist>
	  <tag><tt>linux-headers[-<em>subarch</em>]-<em>version</em>-<em>abiname</em>-<em>flavour</em></tt></tag>
	  <item>
	    This package provides flavour-specific header files. It depends on the corresponding
	    <tt>linux-headers[-<em>subarch</em>]-<em>version</em>-<em>abiname</em></tt> package, and
	    sets up symbolic links into its directory tree in such a way that the directory 
	    <tt>/usr/src/linux-headers[-<em>subarch</em>]-<em>version</em>-<em>abiname</em>-<em>flavour</em></tt>
	    appears to contain a full set of headers, required for building of out-of-tree kernel modules.
	    For more information on this check out <ref id="common-out-of-tree">. A complete
	    set of kernel headers matching the currently running official kernel may be installed with
	    a command
	    <example>
apt-get install linux-headers-$(uname -r)
            </example>
	  </item>
	  <tag><tt>linux-image[-<em>subarch</em>]-<em>flavour</em></tt></tag>
	  <item>
	    <p>
	      This is a virtual package, providing (via dependencies) the latest
	      binary image for a particular flavour. Example: <tt>linux-image-alpha-smp</tt>.
	  </item>
	  <tag><tt>linux-image[-<em>subarch</em>]-<em>major</em>-<em>flavour</em></tt></tag>
	  <tag><tt>linux-headers[-<em>subarch</em>]-<em>major</em>-<em>flavour</em></tt></tag>
	  <item>
	    <p>
	      These virtual packages provide (via dependencies) the latest 
	      <tt><em>major</em></tt> series binary image and matching set of header files (respectively) 
	      for a particular flavour. Example: <tt>linux-image-2.6-alpha-smp</tt>
	  </item>
	  <tag><tt>linux-image[-<em>subarch</em>]-<em>version</em>-<em>abiname</em>-<em>flavour</em></tt></tag>
	  <item>
	    <p>
	      This package contains the binary kernel image and
	      pre-built binary modules for a particular
	      arch/subarch/flavour combination. Names of the files
	      installed by this package are
	      architecture-dependent. Typical locations of essential
	      files for the <tt>i386</tt> architecture are:
	      <taglist>
	        <tag><tt>/boot/vmlinuz-<em>version</em>-<em>abiname</em>-<em>flavour</em></tt></tag>
		<item>
		  The binary (compressed) kernel image.
		</item>
	        <tag><tt>/boot/initrd.img-<em>version</em>-<em>abiname</em>-<em>flavour</em></tt></tag>
		<item>
		  Initial RAM disk/filesystem (initrd/initramfs) image. Note, that this file is automatically generated
		  in the installation process and is <strong>not</strong> shipped as a part of the package.
		  See <ref id="initramfs"> for more details.
		</item>
		<tag><tt>/boot/config-<em>version</em>-<em>abiname</em>-<em>flavour</em></tt></tag>
		<item>
		  The kernel configuration file used to build this particular kernel. May be used
		  to rebuild the kernel from source, if necessary.
		</item>
		<tag><tt>/lib/modules/<em>version</em>-<em>abiname</em>-<em>flavour</em>/</tt></tag>
		<item>
		  Directory containing the pre-built binary kernel modules.
		</item>
	      </taglist>
	    <p>	      
	      There are usually a <tt>/boot/vmlinuz</tt> and
	      <tt>/boot/initrd.img</tt> symbolic links, pointing to
	      the currently used kernel file and initrd image
	      respectively. Upon the installation of a new kernel, the
	      post-installation script included in the package will
	      point this links to newly installed kernel and initrd,
	      which may be named <tt>/boot/vmlinuz-2.6.12-1-686</tt>
	      and <tt>/boot/initrd.img-2.6.12-1-686</tt>, for example.
	      It will also create the links <tt>/boot/vmlinuz.old</tt>
	      and <tt>/boot/initrd.img.old</tt> pointing to the
	      previously used kernel and initrd, and configure the
	      bootloader so that the old kernel may be booted in case
	      something goes wrong.
	  </item>
	  <tag><tt>kernel-image[-<em>subarch</em>]-<em>major</em>-<em>flavour</em></tt></tag>
	  <item>
	    <p>
	      These are transitional packages, introduced to provide a smooth
	      upgrade path from the earlier (pre-2.6.12) kernel versions. Their
	      sole purpose is to depend on the corresponding 
	      <tt>linux-image[-<em>subarch</em>]-<em>major</em>-<em>flavour</em></tt>
	      package.
	  </item>	  
	  </taglist>
	</p>
      </sect>
      <sect id="other-pkg">
        <heading>Other kernel-related packages</heading>
	<p>
	  To be contributed.
	</p>
      </sect>
    </chapt>
    <chapt id="common-tasks">
      <heading>Common kernel-related tasks</heading>
      <sect id="common-getting">
        <heading>Obtaining the Debian kernel source</heading>
	<p>
	  To get the Debian kernel source at the current maximum patchlevel,
	  it is sufficient to install the latest <tt>linux-source-<em>version</em></tt>
	  package and unpack the source, for example:
	  <example>
# apt-get install linux-source-2.6.17
$ tar jxf /usr/src/linux-source-2.6.17.tar.bz2
          </example>
	  The unpacked source tree then will be available in <tt>linux-source-2.6.12</tt> directory.
	</p>
	
	<p>
	  In order to get the Debian kernel source at the patchlevel
	  <em>different</em> from the one provided by the current
	  <tt>linux-source-<em>version</em></tt> package, one should
	  first install and unpack it, then roll back the unneeded
	  patch sets using a script from the <tt>linux-patch-debian-<em>version</em></tt> 
	  package. We assume that in the steps mentioned in the
	  previous example the version 2.6.12-3 of the
	  <tt>linux-source-2.6.12</tt> package was installed and
	  unpacks, so that the Debian kernel source at patchlevel 3 is
	  available in the <tt>linux-source-2.6.12</tt> directory. It
	  can then be rolled back to the desired patchlevel (1 in the
	  example below) by running
	  <example>
# apt-get install linux-patch-debian-2.6.12
$ cd linux-source-2.6.12
$ /usr/src/kernel-patches/all/2.6.12/apply/debian 2.6.12-1
          </example>
	  The last command will <em>unapply</em> the set of patches,
	  which lead from patchlevel 1 to patchlevel 3 and the
	  resulting tree will appear as if it came from the version
	  2.6.12-1 of the <tt>linux-source-2.6.12</tt> package. This
	  system ensures that the source code for any revision of the
	  Debian kernel source may be recovered from the latest one,
	  without keeping multiple copies of the source in the
	  archive.
	</p>

	<p>

	  The version <tt><em>version</em>-<em>N</em></tt> (like
	  2.6.12-3) of the <tt>linux-patch-debian-<em>version</em></tt> 
	  package contains all the individual patches applied to the
	  source to achieve any patchlevel up to <tt><em>N</em></tt>.
	  They are stored in the directory
	  <tt>/usr/src/kernel-patches/all/<em>version</em>/debian/</tt>.


	</p>

      </sect>
      <sect id="common-official">
        <heading>Rebuilding an official Debian kernel package</heading>
	<p>
	  To locally build a kernel image identical to the one
	  distributed in the Debian archive use the following
	  procedure:
	  <taglist>
	    <tag><tt>$ apt-get source linux-<em>major</em></tt></tag>	      
	    <item>
	      This will download and unpack the
	      <tt>linux-<em>major</em></tt> source package, making the
	      tree available in the
	      <tt>linux-<em>major</em>-<em>version</em></tt>
	      directory. As always, the revision part of the version
	      of this package (for example, 3 in 2.6.12-3) will
	      determine its patchlevel with respect to the original
	      upstream kernel source.
	    </item>
	    <tag><tt># apt-get install build-essential fakeroot</tt></tag>
	    <tag><tt># apt-get build-dep linux-<em>major</em></tt></tag>
	    <item>
	      The last two commands will install the build dependencies required by the kernel
	      build process.
	    </item>
	    <tag><tt>$ cd linux-<em>major</em>-<em>version</em></tt></tag>
	    <tag><tt>$ fakeroot debian/rules binary</tt></tag>
	    <item>
	      The last command will start the kernel build and should
	      result in creation of the kernel packages, identical to
	      the official ones in the original directory (in which
	      the source package was unpacked). It is possible to
	      specify the targets <tt>binary-arch</tt> or
	      <tt>binary-indep</tt> targets instead of the
	      <tt>binary</tt>, if only architecture-dependent (such as
	      the <tt>linux-image</tt>) or architecture-independent
	      packages are required. It is possible to further
	      restrict the build to only the desired flavours of the
	      kernel images by invoking the individual targets directly.
	      For example, to build only the binary packages for 686 
	      flavour on i386 architecture, use the following commands:
	      <example>
$ fakeroot debian/rules debian/build debian/stamps
$ fakeroot make -f debian/rules.gen binary-arch-i386-none-686
	      </example>
	      The target in the last command has general form of
	      <tt><em>target</em>-<em>arch</em>-<em>subarch</em>-<em>flavour</em></tt>.
	      Replace the <tt><em>subarch</em></tt> with <tt>none</tt> if it is empty.
	    </item>
	  </taglist>
	</p>
	
	<p>
	  To build the official kernel using the Debian kernel source
	  at the lower patchlevel, than the one provided by the
	  <tt>linux-source-<em>version</em></tt> source package,
	  adjust the <tt>ltver</tt> variable at the top of the
	  <tt>debian/rules</tt> file to the desired patchlevel after
	  unpacking. You should also remove the unneccessary entries
	  in <tt>debian/changelog</tt>, so that the first line
	  contains the correct version
	  <tt><em>version</em>-<em>patchlevel</em></tt> (in
	  brackets). After that proceed with the build as described
	  above.
	</p>

	<p>
	  It is possible to apply extra patches to the tree before
	  starting the build. To do that, before invoking the
	  <tt>binary</tt> or <tt>binary-arch</tt> target, use the
	  <tt>setup</tt> target to unpack the tree and prepare it for
	  a build:
	  <example>
$ fakeroot debian/rules debian/build debian/stamps
$ fakeroot make -f debian/rules.gen setup-i386-none-686
	  </example>
	  This will unpack the kernel tree in the
	  <tt>debian/build/build-i386-none-686</tt> directory, where the extra
	  patches may be applied. After that the <tt>binary</tt> or
	  <tt>binary-arch</tt> target may be invoked to complete the
	  build, as described above.
	</p> 
      </sect>
      <sect id="common-building">
        <heading>Building a custom kernel from Debian kernel source</heading>
	<p>
	  This chapter describes the simplest possible procedure to
	  build a custom kernel the "Debian way". It is assumed that
	  user is somewhat familiar with kernel configuration and
	  build process. If that's not the case, it is recommended to
	  consult the kernel documentation and many excellent online
	  resources dedicated to it.
        </p>
	<p>
	  The easiest way to build a custom kernel (the kernel with
	  the configuration different from the one used in the
	  official packages) from the Debian kernel source is to use
	  the <tt>linux-source</tt> package and the <tt>make-kpkg</tt>
	  command, available as a part of the <tt>kernel-package</tt>.
	  First, prepare the kernel tree:
	  <example>
# apt-get install linux-source-2.6.17
$ tar xjf /usr/src/linux-source-2.6.17.tar.bz2
$ cd linux-source-2.6.17
          </example>
	  The kernel now needs to be configured, that is you have to
	  set the kernel options and select the drivers which are
	  going to be included, either as built-in, or as external
	  modules. The kernel build infrastructure offers a number of
	  targets, which invoke different configuration frontends. For
	  example, one can use console-based menu configuration by
	  invoking the command
	  <example>
$ make menuconfig
          </example>
	  Instead of <tt>menuconfig</tt> one can use <tt>config</tt>
	  (text-based line-by-line configuration frontend) or
	  <tt>xconfig</tt> (graphical configuration frontend). It is
	  also possible to reuse your old configuration file by
	  placing it as a <tt>.config</tt> file in the top-level
	  directory and running one of the configuration targets (if
	  you want to adjust something) or <tt>make oldconfig</tt>.
	  Note that different frontends may require different
	  additional libraries and utilities to be installed to
	  function properly. For example, the <tt>menuconfig</tt>
	  frontend requires the <tt>ncurses</tt> library, which at
	  time of writing is provided by the <tt>libncurses5-dev</tt>
	  package.
	</p>
	<p>
	  After the configuration process is finished, the new or
	  updated kernel configuration will be stored in
	  <tt>.config</tt> file in the top-level directory. Once it's
	  in place, you need to decide whether you want a kernel with
	  or without initrd/initramfs support.  See <ref id="initramfs"> for
	  details on what initrd is. If you decide to go for a
	  initrd-enabled kernel, it should include the initrd support
	  in its configuration. The build for a non-initrd kernel is
	  started using the commands
	  <example>
$ make-kpkg clean
$ fakeroot make-kpkg --revision=custom.1.0 kernel_image
          </example>
	  The <tt>custom.1.0</tt> part in this command is the version
	  identifier, which will get appended to the kernel package
	  name. Feel free to adjust it to your liking. For an
	  initrd-enabled kernel add an extra <tt>--initrd</tt> argument
	  to the second command:
	  <example>
$ make-kpkg clean
$ fakeroot make-kpkg --initrd --revision=custom.1.0 kernel_image
          </example>
	  As a result of the build a custom kernel package
	  <tt>linux-image-2.6.17_custom.1.0_i386.deb</tt> (name will
	  reflect the version of the kernel and the revision chosen in
	  the command line above) will be created in the directory one
	  level above the top of the tree. It may be installed using
	  <tt>dpkg</tt> as any other package:
	  <example> 
# dpkg -i ../linux-image-2.6.17_custom.1.0_i386.deb
	  </example>
	  This command will unpack the kernel, generate the initrd if
	  necessary (see <ref id="initramfs"> for details), and configure
	  the bootloader to make the newly installed kernel the
	  default one. If this command completed without any problems,
	  you can reboot using the
	  <example>
# shutdown -r now
          </example>
	  command to boot the new kernel.
	</p>
	<p>
  	  For much more information about <tt>make-kpkg</tt>,
	  bootloaders and their configuration please check their
	  documentation, which can be accessed using the commands
	  <tt>man make-kpkg</tt>, <tt>man lilo</tt>, <tt>man
	  lilo.conf</tt>, <tt>man grub</tt>, and so on. You can also
	  look for documentation in the
	  <tt>/usr/share/doc/<em>package</em></tt> directories, with
	  <tt><em>package</em></tt> being the name of the package
	  involved.
	</p>  
      </sect>
      <sect id="kernel-org-package">
        <heading>Building a custom kernel from kernel.org</heading> 
	<p>There may be situtations where latest Debian snapshot in
           unstable or experimental is not young enough. Together
           with the instructions of the previous chapter this will
           enable you to build kernels from kernel.org the debian way.
	</p>
        <p>Start by downloading the latest release from kernel.org with your
           favourite browser or wget.</p>
	  <example> 
wget http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.17.tar.bz2{.sign,}
wget http://kernel.org/pub/linux/kernel/v2.6/testing/patch-2.6.18-rc2.bz2{.sign,}
	  </example> 
          <p>Verify it's integrity:</p>
	  <example> 
gpg --verify linux-2.6.17.tar.bz2{.sign,}
gpg --verify patch-2.6.18-rc2.bz2{.sign,}
	  </example> 
          <p>Unpack it and apply the patch:</p>
	  <example> 
tar -xjf linux-2.6.17.tar.bz2
cd linux-2.6.17
bzcat ../patch-2.6.18-rc2.bz2 | patch -p1
	  </example> 
          <p>Base yourself on a working config:</p>
	  <example> 
cp /boot/config-2.6.17-1-686 .config
yes "" | make oldconfig
	  </example> 
          <p>Now everything is prepared to compile and create the
          linux-image package, which will be found one dir higher if the
          compilation works out:</p>
	  <example> 
make-kpkg --initrd --revision 01 linux-image
	  </example> 
      </sect>
      <sect id="common-out-of-tree">
        <heading>Building out-of-tree kernel modules</heading> 
	<p>
	  To be contributed.
	</p>
      </sect>
      <sect id="common-debian-patches">
        <heading>Building kernels with packaged patches</heading>
	<p>
	  To be contributed.
	</p>
      </sect>
      <sect id="common-ext-patches">
        <heading>Building kernels with third-party patches</heading>
	<p>
	  To be contributed.
	</p>
      </sect>
    </chapt>
    <chapt id="modules">
      <heading>Managing the kernel modules</heading>
    </chapt>
    <chapt id="initramfs">
      <heading>Managing the initial ramfs (initramfs) archive</heading>
      <p>
        <strong>Note:</strong> the information in this section mostly applies
	to the kernel packages starting with version 2.6.12.
      </p>
      <p>
        The boot process in Debian is a two-stage process, involving
	the initial RAM filesystem (initramfs for short, sometimes it
	is also referred to as initrd, which stands for initial RAM
	disk). First, the bootloader loads the kernel and initramfs
	into memory, and passes the execution control to the
	kernel. After basic initialization the kernel extracts the
	initramfs archive and mounts it as a temporary root
	filesystem. initramfs contains kernel modules and userspace
	programs required to initialize the physical or logical
	device(s) containing the real root filesystem. The
	<tt>init</tt> script on the initramfs loads modules and
	performs other neccessary initialization steps. At the end of
	this stage <tt>run-init</tt> deletes the initramfs from
	memory, mounts the real root filesystem and passes control to
	the <tt>/sbin/init</tt> program on it.
      </p>
      <p>
        Two major goals are achieved with such setup: the kernel size
	is kept under control by allowing most of the drivers to be
	compiled as modules (in a initramfs-less setup the drivers
	neccessary for the boot-time initialization of the root device
	must be compiled into it) and allow the setups which require
	initialization which cannot be done in-kernel, but is performed
	by userspace utilities.
      </p>
      <sect id="initramfs-gen-tools">
        <heading>Initramfs generation tools</heading>
      <p>
        Since initramfs usually needs to be customized for the particular
	hardware/device configuration and kernel version, they are not
	included as a part of any package, but are generated on the
	fly at kernel installation time. Currently there are two tools
	in Debian, capable of creating an initramfs for kernels 2.6.13
	and newer: <tt>mkinitrd.yaird</tt> provided by the
	<tt>yaird</tt> package, and <tt>update-initramfs</tt> provided by
	<tt>initramfs-tools</tt>. The strategies these utilities use
	for initramfs creation are quite different. <tt>yaird</tt>
	performs a scan of the machine configuration at the kernel
	installation time and includes only the modules and programs
	which are required to initialize the device containing the
	current root filesystem. <tt>initramfs-tools</tt>, on the other hand,
	includes most of the controller drivers, as well as the tools
	to do automatic hardware detection from the initrd during
	boot.  The resulting initramfs is typically a few times larger
	than the one generated by <tt>yaird</tt>, however it comes with a
	greater flexibility.  For example, a disk containing a kernel
	and initramfs generated by <tt>initramfs-tools</tt> may be moved
	to another partition or machine and is likely to successfully
        boot there (attached to a different disk controller, let's say),
	than the one containing a <tt>yaird</tt>-generated initramfs. A
	detailed comparison of the features of two package is
	available on the <url id="http://wiki.debian.org" name="Debian
	Wiki"> page <url
	id="http://wiki.debian.org/InitrdReplacementOptions"
	name="InitrdReplacementOptions">. You can also consult the
	manual pages of the individual tools by runnning the commands
	<tt>man mkinitrd.yaird</tt> and <tt>man update-initramfs</tt>.
      </p>
      </sect>
      <sect id="initramfs-gen-process">
        <heading>Choosing the tool</heading>
      <p>
	At the end of the kernel package installation a script is
	automatically invoked to determine the availability of the
	initramfs-generating tools and run one of them. This script
	contains the list of all such tools available in Debian
	(currently there are three, two mentioned above and
	<tt>mkinitrd</tt> from the <tt>initrd-tools</tt> package,
	which is required to generate old-style initrds for older
	kernels). If the tool is installed (and the dependencies of
	the <tt>linux-image</tt> package ensure that at least one of
	them is installed), it will be queried (by running it with
	<tt>--supported-host-version</tt> and
	<tt>--supported-target-version</tt>) to determine whether it
	can be used to generate the initramfs for the new kernel version
	when running on a system with a current kernel version.  The
	first tool which is found to satisfy the criteria is going to
	be invoked, generating the new initramfs image and placing it
	into <tt>/boot</tt> directory. See the documentation of the
	individual tools for the supported ranges of kernel versions.
      </p>
      <p>
        The list of tools to be considered and the order in which they
	are tested may be controlled by placing a space-separated list
	of the executables into the <tt>ramdisk</tt> variable in
	<tt>/etc/kernel-img.conf</tt>. For example, the current
	default order is <tt>initramfs-tools</tt>, <tt>yaird</tt>, 
	<tt>initrd-tools</tt>.  If one prefers to use exclusively
	<tt>initramfs-tools</tt> with newer kernels, the following
	setting in <tt>/etc/kernel-img.conf</tt> will prevent the
	initrd generation script from considering <tt>yaird</tt> as
	a candidate:
	<example>
ramdisk = /usr/sbin/mkinitramfs-kpkg /usr/sbin/mkinitrd
        </example>
      </p>
      </sect>
      <sect id="initramfs-regen">
        <heading>Regenerating the initramfs</heading>
      <p>
        The <tt>ramdisk</tt> setting mentioned above will only take
	effect when implemented <em>before</em> the kernel image
	installation. If the changes are desired after the corresponding
	<tt>linux-image</tt> has been installed, the initramfs needs to
	be regenerated. This is achieved by the command
	<example>
# dpkg-reconfigure linux-image-2.6.17-1-686
        </example>
        where <tt>linux-image-2.6.17-1-686</tt> is the name of the
	kernel package for which the initrd regeneration is requested.
      </sect>
      <sect id="initramfs-exam">
        <heading>Examining the initramfs contents</heading>
	<p>
	Occasionally it is useful to examine the contents of initramfs
	to diagnose a problem or for educational purposes. The old-style
	initrds created by <tt>/usr/sbin/mkinitrd</tt> from <tt>initrd-tools</tt>
	package are either <tt>cramfs</tt> or <tt>ext2</tt> filesystem, so
	they need to be mounted to access their contents. This may be achieved
	with the commands like
	<example>
# mkdir -p /mnt/initrd
# mount -t cramfs /boot/initrd.img-2.6.12-1-686 /mnt/initrd -o loop
        </example>
	New style initramfs, created by <tt>yaird</tt> or <tt>initramfs-tools</tt>
	are compressed <tt>cpio</tt> archives, which may be extracted using the
	command 
	<example>
$ zcat /boot/initrd.img-2.6.17-1-686 | cpio -i
        </example>
	It will unpack the contents of the initramfs into the current directory.
      </sect>
    </chapt>
    <chapt id="bugs">
      <heading>Filing a bug against a kernel package</heading>
      <p>
        <em>This chapter is a WORK IN PROGRESS! The information here
	    has not been endorsed by all members of the kernel team
	    yet.
	</em>
      </p>
      <p>
        Debian kernel team keeps track of the kernel package bugs in
	the Debian Bug Tracking System (BTS). For information on how
	to use the system see <url id="http://bugs.debian.org"
	name="http://bugs.debian.org">.  You can also submit the bugs
	by using the <tt>reportbug</tt> command from the package with
	the same name. Please note that kernel bugs found in
	distributions derived from Debian (such as Knoppix, Mepis,
	Progeny, Ubuntu, Xandros, etc.) should <em>not</em> be
	reported to the Debian BTS (unless they can be also reproduced
	on a Debian system using official Debian kernel
	packages). Derived distributions have their own policies and
	procedures regarding kernel packaging, so the bugs found in
	them should be reported directly to their bug tracking systems
	or mailing lists.
      </p>
      <p>
        Nothing in this chapter is intended to keep you from filing a
	bug against one of the Debian kernel packages.  However, you should
	recognize that the resources of the Debian kernel team are
	limited, and efficient reaction to a bug is largely determined
	by the amount and quality of the information included in the
	bug report. Please help us to do a better job by using the
	following guidelines when preparing to file the bug against
	kernel packages:
      <list>
	<item>
	  <em>Do the research.</em> Before filing the bug search the
	  web for the particular error message or symptom you are
	  getting. As it is highly unlikely that you are the only
	  person experiencing a particular problem, there is always a
	  chance that it has been discussed elsewhere, and a possible
	  solution, patch, or workaround has been proposed. If such
	  information exists, always include the references to it in
	  your report. Check the <url id="http://bugs.debian.org/cgi-bin/pkgreport.cgi?src=linux-2.6" name="current bug list">
	  to see whether something similar has been reported already.
	</item>
	<item>
	  <em>Collect the information.</em> Please provide enough
	  information with your report. At a minimum, it should
	  contain the exact version of the official Debian kernel
	  package, where the bug is encountered, and steps to
	  reproduce it. Depending on the nature of the bug you
	  reporting, you might also want to include the output of
	  <tt>dmesg</tt> (or portions thereof), output of the
	  <tt>lspci -vn</tt>. If applicable,
	  include the information about the latest known kernel
	  version where the bug is not present, and output of the
	  above commands for the working kernel as well. Use
	  common sense and include other relevant information,
	  if you think that it might help in solving the problem.
	</item>
	<item>
	  <em>Try to reproduce the problem with "vanilla" kernel.</em>
	  If you have a chance, try to reproduce the problem by
	  building the binary kernel image from the "vanilla" kernel
	  source, available from <url id="http://www.kernel.org"
	  name="http://www.kernel.org"> or its mirrors, using the same
	  configuration as the Debian stock kernels. For more
	  information on how to do this, look at <ref
	  id="common-building">. If there is convincing evidence that
	  the buggy behavior is caused by the Debian-specific changes
	  to the kernel, the bug will usually be assigned higher
	  priority by the d-k team. If the bug is not specific for
	  Debian, check out the upstream <url
	  id="http://bugzilla.kernel.org" name="kernel bug database">
	  to see if it has been reported there. If you are sure that
	  it is an upstream problem, you can also report your bug
	  there (but submit it to Debian BTS anyway, so that we can
	  track it properly).
	</item>
        <item>
          <em>Use the correct package to report the bug against.</em>
	  All the binary kernel packages are produced from a single
	  <tt>linux-2.6</tt> source package. Because of that, the
	  usual way for d-k team members to scan for bugs is to look
	  at the list of bugs for the <tt>linux-2.6</tt> source
	  package, available at <url
	  id="http://bugs.debian.org/cgi-bin/pkgreport.cgi?src=linux-2.6"
	  name="http://bugs.debian.org/cgi-bin/pkgreport.cgi?src=linux-2.6">.
	  It is therefore crucial that you report the bug against one
	  of the binary packages listed on that page (check that it
	  shows up on that page after you do!). If in doubt, file the
	  bug against the binary package <tt>linux-2.6</tt>, which is
	  also built from the <tt>linux-2.6</tt> source. Failure to
	  follow that rule will drastically reduce the chances that
	  your bug will be noticed by the d-k team and acted upon.
        </item>
	<item>
	  <em>Bugs involving <tt>PREEMPT</tt>.</em> Even in the latest
	  kernels making the kernel preemptible (by enabling the
	  <tt>CONFIG_PREEMPT</tt> configuration option) will
	  occasionally lead to problems in form of occasional kernel
	  oops. For this reason this option is disabled in Debian
	  kernel packages, so problem can only be triggered with a
	  custom kernel. It is known to the upstream kernel developers
	  and it is most likely that d-k team will not be able to do
	  anything about it.
	</item>
	<item>
	  <em>Bugs involving ACPI.</em> While ACPI (Advanced Control
	  and Power Interface) support in Linux kernel has matured
	  greatly in the 2.6 series, it occasionally causes problems
	  (misrouted interrupts, failure to go into or return from the
	  sleep/hybernation/suspend mode) on newer laptop models. They
	  may be caused both by bugs in the kernel code or (more
	  likely) in the ACPI interface of a particular machine. As
	  resolution of such bugs requires access to the machine in
	  question, it is pretty unlikely that d-k team will be able
	  to do something about it. Consider reporting the problem to
	  the <url
	  id="http://vger.kernel.org/vger-lists.html#linux-acpi"
	  name="Linux ACPI mailing list"> along with the submission to
	  the Debian BTS. As a workaround, try booting the kernel with
	  some combination of boot options <tt>acpi=off</tt>,
	  <tt>pci=norouteirq</tt>, <tt>pci=noacpi</tt>, and
	  <tt>nolapic</tt> to see if that improves the situation.
	</item>
	<item>
	  <em>Bugs involving tainted kernels.</em> If a kernel
	  crashes, it would normally print out some debugging
	  information, indicating, among other things, whether the
	  running kernel has been tainted. The kernel is referred to
	  as tainted if at the time of the crash it had some binary
	  third-party modules loaded. As kernel developers do not
	  have access to the source code for such modules, problems
	  involving them are notoriously difficult to debug. It is
	  therefore strongly recommended to try and reproduce the
	  problem with an untainted kernel (by preventing the loading
	  of binary modules, for example). If the problem is due to
	  the presence of such modules, there is not much the kernel
	  community can do about it and it should be reported directly
	  to their authors.
	</item>
      </list>
      </p>
    </chapt>
    <chapt id="developer">
      <heading>Information for developers of the kernel packages</heading>
      <sect id="dev-patches">
        <heading>Packaging the kernel patches</heading>
      </sect>
      <sect id="dev-modules">
        <heading>Packaging third-party kernel modules</heading>
      </sect>
    </chapt>
  </book>
</debiandoc>
<!-- vim:set ai et sts=2 sw=2 tw=76: -->
